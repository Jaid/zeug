export const defaultDynamicPredicate = key => {
    if (typeof key !== `string`) {
        return false;
    }
    return key.endsWith(`.map`);
};
export const defaultKeyMapper = (key, isDynamic) => {
    if (typeof key !== `string`) {
        return key;
    }
    if (isDynamic) {
        return key.slice(0, -4);
    }
    return key;
};
export const expandMaps = (input, dynamicPredicate = defaultDynamicPredicate, keyMapper = defaultKeyMapper) => {
    const keys = {};
    for (const [key, value] of Object.entries(input)) {
        const currentKey = key;
        const meta = {
            isActuallyDynamic: false,
            isDynamic: dynamicPredicate(key, value),
        };
        if (meta.isDynamic) {
            if (!Array.isArray(value)) {
                meta.value = value;
            }
            else if (value.length === 0) {
                continue;
            }
            else if (value.length === 1) {
                meta.value = value[0];
            }
            else {
                meta.isActuallyDynamic = true;
            }
        }
        else {
            meta.value = value;
        }
        keys[currentKey] = meta;
    }
    const dynamicKeys = Object.keys(keys).filter(key => keys[key].isActuallyDynamic);
    if (!dynamicKeys.length) {
        return [input];
    }
    const combinations = dynamicKeys.reduce((accumulator, key) => {
        const currentArray = input[key];
        return accumulator.flatMap(accumulatorElement => {
            return currentArray.map(currentArrayElement => {
                return [...accumulatorElement, currentArrayElement];
            });
        });
    }, [[]]);
    const output = combinations.map(combination => {
        const result = {};
        for (const key of Object.keys(keys)) {
            const keyMeta = keys[key];
            const normalizedKey = keyMapper(key, keyMeta.isDynamic, keyMeta.isActuallyDynamic);
            const value = keyMeta.isActuallyDynamic ? combination[dynamicKeys.indexOf(key)] : keyMeta.value;
            result[normalizedKey] = value;
        }
        return result;
    });
    return output;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwYW5kTWFwcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9leHBhbmRNYXBzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUlBLE1BQU0sQ0FBQyxNQUFNLHVCQUF1QixHQUFxQixHQUFHLENBQUMsRUFBRTtJQUM3RCxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQzVCLE9BQU8sS0FBSyxDQUFBO0lBQ2QsQ0FBQztJQUNELE9BQU8sR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQTtBQUM3QixDQUFDLENBQUE7QUFFRCxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLEdBQVEsRUFBRSxTQUFrQixFQUFFLEVBQUU7SUFDL0QsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUUsQ0FBQztRQUM1QixPQUFPLEdBQUcsQ0FBQTtJQUNaLENBQUM7SUFDRCxJQUFJLFNBQVMsRUFBRSxDQUFDO1FBQ2QsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBO0lBQ3pCLENBQUM7SUFDRCxPQUFPLEdBQUcsQ0FBQTtBQUNaLENBQUMsQ0FBQTtBQVFELE1BQU0sQ0FBQyxNQUFNLFVBQVUsR0FBRyxDQUFpQyxLQUFRLEVBQUUsbUJBQXFDLHVCQUF1QixFQUFFLFlBQXVCLGdCQUFnQixFQUFFLEVBQUU7SUFDNUssTUFBTSxJQUFJLEdBQXNDLEVBQUUsQ0FBQTtJQUNsRCxLQUFLLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQ2pELE1BQU0sVUFBVSxHQUFhLEdBQUcsQ0FBQTtRQUNoQyxNQUFNLElBQUksR0FBWTtZQUNwQixpQkFBaUIsRUFBRSxLQUFLO1lBQ3hCLFNBQVMsRUFBRSxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO1NBQ3hDLENBQUE7UUFDRCxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNuQixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUMxQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQTtZQUNwQixDQUFDO2lCQUFNLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztnQkFDOUIsU0FBUTtZQUNWLENBQUM7aUJBQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO2dCQUM5QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUN2QixDQUFDO2lCQUFNLENBQUM7Z0JBQ04sSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQTtZQUMvQixDQUFDO1FBQ0gsQ0FBQzthQUFNLENBQUM7WUFDTixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQTtRQUNwQixDQUFDO1FBQ0QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLElBQUksQ0FBQTtJQUN6QixDQUFDO0lBQ0QsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFFLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtJQUNqRixJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3hCLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUNoQixDQUFDO0lBQ0QsTUFBTSxZQUFZLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFdBQVcsRUFBRSxHQUFHLEVBQUUsRUFBRTtRQUMzRCxNQUFNLFlBQVksR0FBZSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUE7UUFDM0MsT0FBTyxXQUFXLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLEVBQUU7WUFDOUMsT0FBTyxZQUFZLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLEVBQUU7Z0JBQzVDLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixFQUFFLG1CQUFtQixDQUFDLENBQUE7WUFDckQsQ0FBQyxDQUFDLENBQUE7UUFDSixDQUFDLENBQUMsQ0FBQTtJQUNKLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7SUFDUixNQUFNLE1BQU0sR0FBUyxZQUFZLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFO1FBQ2xELE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQTtRQUNqQixLQUFLLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztZQUNwQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFFLENBQUE7WUFDMUIsTUFBTSxhQUFhLEdBQUcsU0FBUyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFBO1lBQ2xGLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQTtZQUMvRixNQUFNLENBQUMsYUFBYSxDQUFDLEdBQUcsS0FBSyxDQUFBO1FBQy9CLENBQUM7UUFDRCxPQUFPLE1BQU0sQ0FBQTtJQUNmLENBQUMsQ0FBQyxDQUFBO0lBQ0YsT0FBTyxNQUFNLENBQUE7QUFDZixDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJ0eXBlIEtleSA9IG51bWJlciB8IHN0cmluZyB8IHN5bWJvbFxudHlwZSBEeW5hbWljUHJlZGljYXRlID0gKGtleTogS2V5LCB2YWx1ZTogdW5rbm93bikgPT4gYm9vbGVhblxudHlwZSBLZXlNYXBwZXIgPSAoa2V5OiBLZXksIGlzRHluYW1pYzogYm9vbGVhbiwgaXNBY3R1YWxseUR5bmFtaWM6IGJvb2xlYW4pID0+IEtleVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdER5bmFtaWNQcmVkaWNhdGU6IER5bmFtaWNQcmVkaWNhdGUgPSBrZXkgPT4ge1xuICBpZiAodHlwZW9mIGtleSAhPT0gYHN0cmluZ2ApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4ga2V5LmVuZHNXaXRoKGAubWFwYClcbn1cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRLZXlNYXBwZXIgPSAoa2V5OiBLZXksIGlzRHluYW1pYzogYm9vbGVhbikgPT4ge1xuICBpZiAodHlwZW9mIGtleSAhPT0gYHN0cmluZ2ApIHtcbiAgICByZXR1cm4ga2V5XG4gIH1cbiAgaWYgKGlzRHluYW1pYykge1xuICAgIHJldHVybiBrZXkuc2xpY2UoMCwgLTQpXG4gIH1cbiAgcmV0dXJuIGtleVxufVxuXG50eXBlIEtleU1ldGEgPSB7XG4gIGlzQWN0dWFsbHlEeW5hbWljOiBib29sZWFuXG4gIGlzRHluYW1pYzogYm9vbGVhblxuICB2YWx1ZT86IHVua25vd25cbn1cblxuZXhwb3J0IGNvbnN0IGV4cGFuZE1hcHMgPSA8VCBleHRlbmRzIFJlY29yZDxLZXksIHVua25vd24+PihpbnB1dDogVCwgZHluYW1pY1ByZWRpY2F0ZTogRHluYW1pY1ByZWRpY2F0ZSA9IGRlZmF1bHREeW5hbWljUHJlZGljYXRlLCBrZXlNYXBwZXI6IEtleU1hcHBlciA9IGRlZmF1bHRLZXlNYXBwZXIpID0+IHtcbiAgY29uc3Qga2V5czogUGFydGlhbDxSZWNvcmQ8a2V5b2YgVCwgS2V5TWV0YT4+ID0ge31cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5wdXQpKSB7XG4gICAgY29uc3QgY3VycmVudEtleSA9IDxrZXlvZiBUPiBrZXlcbiAgICBjb25zdCBtZXRhOiBLZXlNZXRhID0ge1xuICAgICAgaXNBY3R1YWxseUR5bmFtaWM6IGZhbHNlLFxuICAgICAgaXNEeW5hbWljOiBkeW5hbWljUHJlZGljYXRlKGtleSwgdmFsdWUpLFxuICAgIH1cbiAgICBpZiAobWV0YS5pc0R5bmFtaWMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbWV0YS52YWx1ZSA9IHZhbHVlXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbWV0YS52YWx1ZSA9IHZhbHVlWzBdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXRhLmlzQWN0dWFsbHlEeW5hbWljID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXRhLnZhbHVlID0gdmFsdWVcbiAgICB9XG4gICAga2V5c1tjdXJyZW50S2V5XSA9IG1ldGFcbiAgfVxuICBjb25zdCBkeW5hbWljS2V5cyA9IE9iamVjdC5rZXlzKGtleXMpLmZpbHRlcihrZXkgPT4ga2V5c1trZXldIS5pc0FjdHVhbGx5RHluYW1pYylcbiAgaWYgKCFkeW5hbWljS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gW2lucHV0XVxuICB9XG4gIGNvbnN0IGNvbWJpbmF0aW9ucyA9IGR5bmFtaWNLZXlzLnJlZHVjZSgoYWNjdW11bGF0b3IsIGtleSkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRBcnJheSA9IDx1bmtub3duW10+IGlucHV0W2tleV1cbiAgICByZXR1cm4gYWNjdW11bGF0b3IuZmxhdE1hcChhY2N1bXVsYXRvckVsZW1lbnQgPT4ge1xuICAgICAgcmV0dXJuIGN1cnJlbnRBcnJheS5tYXAoY3VycmVudEFycmF5RWxlbWVudCA9PiB7XG4gICAgICAgIHJldHVybiBbLi4uYWNjdW11bGF0b3JFbGVtZW50LCBjdXJyZW50QXJyYXlFbGVtZW50XVxuICAgICAgfSlcbiAgICB9KVxuICB9LCBbW11dKVxuICBjb25zdCBvdXRwdXQgPSA8VFtdPiBjb21iaW5hdGlvbnMubWFwKGNvbWJpbmF0aW9uID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGtleXMpKSB7XG4gICAgICBjb25zdCBrZXlNZXRhID0ga2V5c1trZXldIVxuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleU1hcHBlcihrZXksIGtleU1ldGEuaXNEeW5hbWljLCBrZXlNZXRhLmlzQWN0dWFsbHlEeW5hbWljKVxuICAgICAgY29uc3QgdmFsdWUgPSBrZXlNZXRhLmlzQWN0dWFsbHlEeW5hbWljID8gY29tYmluYXRpb25bZHluYW1pY0tleXMuaW5kZXhPZihrZXkpXSA6IGtleU1ldGEudmFsdWVcbiAgICAgIHJlc3VsdFtub3JtYWxpemVkS2V5XSA9IHZhbHVlXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSlcbiAgcmV0dXJuIG91dHB1dFxufVxuIl19